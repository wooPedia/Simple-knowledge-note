# 간단한 프로그래밍 지식 모음


<b>알게된 지식들을 하나씩 추가합니다.</b>
<br><br>

### [클래스 멤버 변수 초기화]
- 생성자 구현부에서 멤버 변수에 값을 대입하는 것은 <b>초기화가 아닌 할당</b>이다. 따라서 함수의 헤더에 사용하는 <b>초기화 리스트 (initializer list)</b>를 사용하자.

```C++
class Foo
{
    Foo()
      : mAge(10)   // 초기화(Initialization)
    {
        mAge = 10; // 할당(Assignment)
    }

    int mAge;
}
```


<br><br>

### [가상 함수와 가상 테이블]
- 가상 함수들을 저장하고 있는 가상 테이블은 클래스마다 하나씩 존재하며, 객체가 할당된 메모리 상에 가상 테이블의 주소가 있다. 따라서 가상 함수가 필요하다면 객체의 메모리에서 가상 테이블의 주소를 찾아 가상 테이블로 간 뒤 가상 테이블에서 원하는 함수의 주소를 또 찾아야 한다. 따라서 <b>가상 함수는 런타임 중 실체를 찾는 동적 바인딩이며 속도가 느리다.</b><br>
하지만 <b>C++의 다형성(Polymorphism)의 핵심 개념인 동일한 interface, 다른 behavior에 있어서 virtual은 중요한 요소</b>이며 부모 클래스 객체를 통해 자식 클래스의 멤버 함수에 동적으로 접근할 수 있게 해준다.
<br><br><br>

### [연결 리스트와 CPU 캐시는 케미가 좋지 않다]
- 링크드 리스트(list in cpp)는 중간에 삽입 및 삭제 연산이 O(1) time complexity를 가져 vector보다 삽입 삭제 연산이 많이 일어날 경우 보다 빠른 자료구조이다. 하지만 <b>(링크드)리스트는 CPU의 캐시 기능과 friendly 할 수 없다.</b> 캐시는 한 번 참조한 메모리의 주변 메모리가 다시 사용될 가능성이 높다고 판단하여 인접한 메모리를 캐시 메모리에 저장한다.<br>
이렇게 참조했던 메모리의 인접 메모리를 다시 참조하는 성질을 공간적 지역성(locality)라고 한다. 그런데 연결 리스트는 불연속적인 메모리 구조를 가진다. 이는 지역성이 좋지 않아 캐시 기능과 케미가 좋지않다. <b>캐시 기능은 연속된 메모리를 할당하는 자료구조인 배열(vector 등)과 케미가 좋다.</b> 실제로 벡터를 사용할 때가 더 빠른 경우가 많다고 하며, list보다 vector가 더 많이 사용된다고 한다.
<br><br><br>

### [동적 할당과 메모리 단편화]
- heap 영역의 빈번한 메모리 재할당은 메모리 단편화를 초래한다. 즉 동적 할당과 해제를 자주하는 것은 좋지않다. 이를 방지하기위해 STL 컨테이너를 사용할 경우 <b>reserve 멤버 함수를 지원한다면 꼭 reserve로 크기를 예약 후 컨테이너를 사용하자.</b>
<br><br><br>

### [템플릿의 장단점과 용도]
- 템플릿 프로그래밍은 컴파일 시간에 적절한 타입으로 코드를 인스턴스화(복사)해주어 <b>컴파일 시간과 코드 크기가 커질 수 있지만 런타임 시간이 적어지기 때문에 유용하게 쓰일 수 있다.</b> 하지만 템플릿 메타 프로그래밍은 <b>코드가 복잡하여 가독성이 떨어지고, 디버깅이 어렵다는 단점</b>이 있다. 따라서 컨테이너와 같이 다양한 타입을 활용할 수 있을 때 주로 사용하고 적은 자료형을 다룬다면 각자 클래스를 만들자. 단, 해당 부분에 있어서 속도가 너무나도 중요하다면 템플릿을 사용하도록 한다.
<br><br><br>


### [auto 키워드와 const]
- auto 키워드로 const 타입 변수를 저장할 때 auto 앞에 const를 붙여주지 않아도 자동으로 const로 받아진다. 하지만 이는 코드를 볼 때 const 여부를 판단하기 어려울 수 있다. 따라서 <b>가독성을 위해 const 타입이라면 auto 앞에 const 키워드를 붙여 const 타입이라는 것을 명시해주자.</b>

```C++
auto& name = GetString();       // 가독성下
const auto& name = GetString(); // 가독성上
```
<br>


### [auto 키워드와 pointer] 
- auto 키워드로 포인터 타입을 받을 때 포인터(*) 타입을 붙이지 않아도 알아서 포인터 타입으로 변환해준다. 하지만 가독성을 위해 포인터를 받으면 auto 키워드에 *을 붙여주자.

```C++
auto  ptr = GetPointer();  // 가독성下
auto* ptr = GetPointer(); // 가독성上
 ```
<br>

### [템플릿 특수화와 오버로딩]
- 클래스 템플릿은 오버로딩이 되지 않지만 함수 템플릿은 오버로딩이 가능하다. 클래스 템플릿은 부분 특수화 또는 완전 특수화 둘다 가능하지만 함수 템플릿은 부분 특수화는 불가능하고 완전 특수화만 가능하다. 하지만 <b>함수 템플릿은 오버로딩을 통해 부분 특수화의 효과를 낼 수 있다.</b>
